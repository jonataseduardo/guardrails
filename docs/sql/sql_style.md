SQL style guide
====================

## Format

- Indents should be two spaces.
- Lines of SQL should not exceed 88 characters (similar to Python Black).
- Field names should be in lowercase, keywords, and function names should all be in uppercase.
- The "AS" keyword should be explicitly used when aliasing a field or table.

You can format your query using [sqlfluff](https://docs.sqlfluff.com/en/stable/) with the following .sqlfluff configuration file.

### Example SQL

```sql
WITH

my_data AS (

  SELECT
    field_1,
    field_2,
    field_3,
    cancellation_date,
    expiration_date,
    start_date

  FROM `project.dataset.table` 
),

some_cte AS (

  SELECT
    id,
    field_4,
    field_5

  FROM my_data 

),

some_cte_agg AS (

  SELECT
    id,
    SUM(field_4) AS total_field_4,
    MAX(field_5) AS max_field_5

  FROM some_cte

  GROUP BY 1

),

joined AS (

  SELECT
    my_data.field_1,
    my_data.field_2,
    my_data.field_3,

    -- use line breaks to visually separate calculations into blocks
    CASE
      WHEN
        my_data.cancellation_date IS NULL
        AND my_data.expiration_date IS NOT NULL
        THEN expiration_date
      WHEN my_data.cancellation_date IS NULL
        THEN my_data.start_date + 7
      ELSE my_data.cancellation_date
    END AS cancellation_date,

    some_cte_agg.total_field_4,
    some_cte_agg.max_field_5

  FROM my_data

  LEFT JOIN some_cte_agg
    ON my_data.id = some_cte_agg.id

  WHERE
    my_data.field_1 = 'abc'
    AND (
      my_data.field_2 = 'def'
      OR my_data.field_2 = 'ghi'
    )

  HAVING COUNT(*) > 1

)

SELECT * FROM joined
```

## Best practices

### Aggregations and Grouping

-   If joining two or more tables, *always* prefix your column names with the table name. If only selecting from one table, prefixes are not needed.
-   Be explicit about your join type (i.e. write `INNER JOIN` instead of `JOIN`).
-   Avoid table aliases in join conditions (especially initialisms) â€” it's harder to understand what the table called `c` is as compared to `customers`.
-   Always move left to right to make joins easy to reason about - `RIGHT JOINS` often indicate that you should change which table you select `FROM` and which one you `JOIN` to.
-   Ordering and grouping by a number (e.g. group by 1, 2) is preferred over listing the column names. Note that if you are grouping by more than a few columns, it may be worth revisiting your model design.
-   Prefer `UNION ALL` to `UNION` unless you explicitly want to remove duplicates.
-   When performance allows, CTEs should perform a single, logical unit of work.
-   CTE names should be as descriptive as necessary to convey their purpose, for example, `events_joined_to_users` instead of `user_events`.
-   The last line of a model should be a `select *` from the final output CTE. 

### Optimize query operations

- Aggregations should be executed as early as possible (on the smallest data set possible) before joining to another table to improve performance.
- Optimize join patterns by starting with the largest table.
- Improve query performance and reduce costs by pruning partitioned queries using the `_PARTITIONTIME` pseudo-column or the partitioning column.
  `BOOL`, `INT`, `FLOAT`, or `DATE` columns are also good candidates in a `WHERE` clause to limit data returned, (i.e avoid joins using `STRINGS`.
- Break down complex queries into smaller ones.
- Optimize query operations by avoiding repeated data transformations, multiple evaluations of the same CTEs, repeated joins and subqueries, and complex queries.
- Materialize transformed results in a destination table for better performance.
- Use procedural language, variables, temporary tables, and automatically expiring tables to persist calculations and use them later in the query.
- Use `INT64` data types in joins instead of `STRING` data types to reduce cost and improve comparison performance.

### Avoid anti-SQL patterns
- Avoid self-joins, use a window (analytic) function instead to reduce the number of additional bytes generated by the query.
- Avoid cross joins that generate more outputs than inputs. Pre-aggregate your data using a `GROUP BY` clause or a window function.
- Avoid DML statements that update or insert single rows. Batch your updates and inserts instead. BigQuery DML statements are intended for bulk updates.
- If your query processes keys that are heavily skewed to a few values, filter your data as early as possible to avoid performance issues.
- Data skew can also appear when you use `JOIN` clauses. To avoid performance issues associated with unbalanced joins, pre-filter rows from the table with the unbalanced key, split the query into two queries, or use the `SELECT DISTINCT` statement when specifying a subquery in the `WHERE` clause.

