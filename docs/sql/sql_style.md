How we style our SQL
====================

Basics
-----------------------------------------------------------------------------

-   Indents should be two spaces.

-   Lines of SQL should not exceed 88 characters.

-   Field names, keywords, and function names should all be in lowercase.

-   The `as` keyword should be explicitly used when aliasing a field or table.



### Example SQL

```sql
    with

    my_data as (

        select
            field_1,
            field_2,
            field_3,
            cancellation_date,
            expiration_date,
            start_date

        from {{ ref('my_data') }}

    ),

    some_cte as (

        select
            id,
            field_4,
            field_5

        from {{ ref('some_cte') }}

    ),

    some_cte_agg as (

        select
            id,
            sum(field_4) as total_field_4,
            max(field_5) as max_field_5

        from some_cte

        group by 1

    ),

    joined as (

        select
            my_data.field_1,
            my_data.field_2,
            my_data.field_3,

            -- use line breaks to visually separate calculations into blocks
            case
                when my_data.cancellation_date is null
                    and my_data.expiration_date is not null
                    then expiration_date
                when my_data.cancellation_date is null
                    then my_data.start_date + 7
                else my_data.cancellation_date
            end as cancellation_date,

            some_cte_agg.total_field_4,
            some_cte_agg.max_field_5

        from my_data

        left join some_cte_agg
            on my_data.id = some_cte_agg.id

        where my_data.field_1 = 'abc' and
            (
                my_data.field_2 = 'def' or
                my_data.field_2 = 'ghi'
            )

        having count(*) > 1

    )

    select * from joined

```

### Aggregations and Grouping

-   If joining two or more tables, *always* prefix your column names with the table name. If only selecting from one table, prefixes are not needed.
-   Be explicit about your join type (i.e. write `inner join` instead of `join`).
-   Avoid table aliases in join conditions (especially initialisms) â€” it's harder to understand what the table called "c" is as compared to "customers".
-   Always move left to right to make joins easy to reason about - `right joins` often indicate that you should change which table you select `from` and which one you `join` to.
-   Ordering and grouping by a number (e.g. group by 1, 2) is preferred over listing the column names. Note that if you are grouping by more than a few columns, it may be worth revisiting your model design.
-   Prefer `union all` to `union` unless you explicitly want to remove duplicates.
 
-   When performance allows, CTEs should perform a single, logical unit of work.
-   CTE names should be as descriptive as necessary to convey their purpose, for example, `events_joined_to_users` instead of `user_events` (although `user_events` could be a good model name, it does not describe a specific function or transformation).
-   The last line of a model should be a `select *` from the final output CTE. 

### Optimize query operations

- Aggregations should be executed as early as possible (on the smallest data set possible) before joining to another table to improve performance.
- Optimize join patterns by starting with the largest table.
- Improve query performance and reduce costs by pruning partitioned queries using the `_PARTITIONTIME` pseudo-column or the partitioning column.
  `BOOL`, `INT`, `FLOAT`, or `DATE` columns are also good candidates in a `WHERE` clause to limit data returned, (i.e avoid joins using `STRINGS`.
- Break down complex queries into smaller ones.
- Optimize query operations by avoiding repeated data transformations, multiple evaluations of the same CTEs, repeated joins and subqueries, and complex queries.
- Materialize transformed results in a destination table for better performance.
- Use procedural language, variables, temporary tables, and automatically expiring tables to persist calculations and use them later in the query.
- Use `INT64` data types in joins instead of `STRING` data types to reduce cost and improve comparison performance.

### Avoid anti-SQL patterns
- Avoid self-joins, use a window (analytic) function instead to reduce the number of additional bytes generated by the query.
- Avoid cross joins that generate more outputs than inputs. Pre-aggregate your data using a `GROUP BY` clause or a window function.
- Avoid DML statements that update or insert single rows. Batch your updates and inserts instead. BigQuery DML statements are intended for bulk updates.
- If your query processes keys that are heavily skewed to a few values, filter your data as early as possible to avoid performance issues.
- Data skew can also appear when you use `JOIN` clauses. To avoid performance issues associated with unbalanced joins, pre-filter rows from the table with the unbalanced key, split the query into two queries, or use the `SELECT DISTINCT` statement when specifying a subquery in the `WHERE` clause.

